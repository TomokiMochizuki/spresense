/****************************************************************************
 * Copyright 2023 Sony Semiconductor Solutions Corporation
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.  The
 * ASF licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 ****************************************************************************/
#include "PCUnit.h"
#include <float.h>
#include <math.h>
#include "mossfw/sensorlib.h"
#include "mossfw/mossdsp.h"
#ifdef UNITTEST
#include <setjmp.h>

static jmp_buf g_testCaseEnv;
#endif

#ifdef CONFIG_ARCH_CHIP_CXD3277
uint32_t cxd3277_systimer_getcntval(void);
static uint32_t timerval = 0;
#endif

static void beginsystimer(void)
{
#ifdef CONFIG_ARCH_CHIP_CXD3277
    timerval = cxd3277_systimer_getcntval();
#endif
}

static void endsystimer(const char *output_name)
{
#ifdef CONFIG_ARCH_CHIP_CXD3277
    uint32_t v;
    v = cxd3277_systimer_getcntval();
    printf("cxd3277 systimer %s, %u, %u\n", output_name, timerval, v);
#endif
    (void)output_name;
}


static void TestMossdspIntegral_integral_gyro_v3i_001(void)
{

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3i(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = (sqrtf(4.5f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3i(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3i(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_integral_gyro_v3i_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    1,
    &param
);


}

epsilon = (sqrtf(4.5f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    in,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    NULL,
    in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3i_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3s_t in[] = {
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0},
    {.x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3i(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_001(void)
{

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3f(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3f(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3f(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_integral_gyro_v3f_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    1,
    &param
);


}

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    in,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    NULL,
    in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3f_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3f_t in[] = {
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in[2].y = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in[2].z = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3f(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_001(void)
{

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = (sqrtf(2.0f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_integral_gyro_v3ti_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    1,
    &param
);


}

epsilon = (sqrtf(2.0f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    in,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    NULL,
    in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3ti_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3ts_t in[] = {
    {.t = 0, .x = 0, .y = 0, .z = 0},
    {.t = 1, .x = 0, .y = 0, .z = 0},
    {.t = 4, .x = 0, .y = 0, .z = 0}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ti(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_001(void)
{

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_integral_gyro_v3tf_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    1,
    &param
);


}

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    in,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    NULL,
    in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_integral_gyro_v3tf_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
mossfw_data_v3tf_t in[] = {
    {.t = 0, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 1, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 4, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
/* axis theta = pi/2, phi = pi/3 */
in[0].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[0].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[0].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in[1].x = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in[1].y = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in[1].z = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in[2].x = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in[2].y = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in[2].z = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tf(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_001(void)
{

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = (sqrtf(4.5f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    1,
    &param
);


}

epsilon = (sqrtf(4.5f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullx,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nully,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nully,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_020(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nully,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_021(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_022(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &nully,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_023(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_024(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_025(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullx,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_026(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_027(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullz,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_028(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_029(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    NULL,
    &nullx,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3ia_030(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
struct vector3ia_s in;
struct vector3ia_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3ia_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(4.5f) * acosf(0.0f)) + 0.5f; /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(4.5f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3ia(
    out,
    &nullz,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_001(void)
{

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    1,
    &param
);


}

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullx,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nully,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nully,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    NULL,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_020(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nully,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_021(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    NULL,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_022(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &nully,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_023(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_024(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_025(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullx,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_026(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_027(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullz,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_028(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_029(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    NULL,
    &nullx,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3fa_030(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qf_t out[] = {
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
struct vector3fa_s in;
struct vector3fa_s nullx = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nully = { .x = NULL, .y = NULL, .z = NULL};
struct vector3fa_s nullz = { .x = NULL, .y = NULL, .z = NULL};
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullx.y = vin[1];
nullx.z = vin[2];
nully.x = vin[0];
nully.z = vin[2];
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(1.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(3.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(4.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.f = {.w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.f = {.w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 1,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3fa(
    out,
    &nullz,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_001(void)
{

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = (sqrtf(2.0f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    1,
    &param
);


}

epsilon = (sqrtf(2.0f) * acosf(0.0f)) / ((float)0x7fff * 2.0f);
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullt,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nully,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullx,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullt,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_020(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullz,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_021(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_022(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_023(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullx,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_024(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nullt,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_025(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_026(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nullx,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_027(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    NULL,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_028(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nully,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_029(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nullt,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_030(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nully,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_031(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nullt,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_032(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    NULL,
    &nullz,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_033(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    &nully,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_034(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tia_035(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
int16_t vin[3][3];
uint16_t tin[3] = {0, 1, 4};
struct vector3tia_s in;
struct vector3tia_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tia_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f) * (float)0x7fff / (sqrtf(2.0f) * acosf(0.0f)) + 0.5f; /*  sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000},
    .scale_factor = (sqrtf(2.0f) * acosf(0.0f)) / (float)0x7fff
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tia(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_001(void)
{

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


#ifdef UNITTEST
if (setjmp(g_testCaseEnv) == 0) {
#endif
beginsystimer();

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
#ifdef UNITTEST
}
#endif

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((cosf(0.0015f * acosf(0.0f))) - epsilon < out[1].w && out[1].w < (cosf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].w) || ((cosf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((cosf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0015f * acosf(0.0f)))) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].x && out[1].x < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].x) || ((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].y && out[1].y < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].y) || ((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) - epsilon < out[1].z && out[1].z < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) && FLT_MAX < out[1].z) || ((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0015f * acosf(0.0f)))) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((cosf(0.003f * acosf(0.0f))) - epsilon < out[2].w && out[2].w < (cosf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].w) || ((cosf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((cosf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.003f * acosf(0.0f)))) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].x && out[2].x < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].x) || ((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].y && out[2].y < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].y) || ((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) - epsilon < out[2].z && out[2].z < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) && FLT_MAX < out[2].z) || ((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.003f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.003f * acosf(0.0f)))) && !(out[2].z < 1.0f || 0.0f < out[2].z)));



beginsystimer();

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
beginsystimer();

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    3,
    &param
);


endsystimer(__func__);
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_002(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    1,
    &param
);


}

epsilon = FLT_EPSILON;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((cosf(0.0005f * acosf(0.0f))) - epsilon < out[0].w && out[0].w < (cosf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (cosf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].w) || ((cosf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((cosf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (cosf(0.0005f * acosf(0.0f)))) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].x && out[0].x < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].x) || ((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.125f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].y && out[0].y < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].y) || ((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.375f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) - epsilon < out[0].z && out[0].z < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) + epsilon) || (FLT_MAX < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) && FLT_MAX < out[0].z) || ((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f))) < 1.0f || 0.0f < (sqrtf(0.5f) * sinf(0.0005f * acosf(0.0f)))) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_003(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &in,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_004(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &in,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_005(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullt,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_006(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nully,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_007(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    NULL,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_008(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullx,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_009(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    NULL,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_010(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullz,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_011(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullt,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_012(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullx,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_013(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_014(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_015(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_016(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 1);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].w && out[1].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].w) || ((0.0f / 0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].x && out[1].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].x) || ((0.0f / 0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].y && out[1].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].y) || ((0.0f / 0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[1].z && out[1].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[1].z) || ((0.0f / 0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 4);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].w && out[2].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].w) || ((0.0f / 0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].x && out[2].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].x) || ((0.0f / 0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].y && out[2].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].y) || ((0.0f / 0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[2].z && out[2].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[2].z) || ((0.0f / 0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_017(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_018(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == 0);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].w && out[0].w < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].w) || ((0.0f / 0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].x && out[0].x < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].x) || ((0.0f / 0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].y && out[0].y < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].y) || ((0.0f / 0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f / 0.0f) - epsilon < out[0].z && out[0].z < (0.0f / 0.0f) + epsilon) || (FLT_MAX < (0.0f / 0.0f) && FLT_MAX < out[0].z) || ((0.0f / 0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f / 0.0f) < 1.0f || 0.0f < (0.0f / 0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_019(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &in,
    1,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_020(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullz,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_021(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &in,
    0,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_022(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &nullz,
    3,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_023(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullx,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_024(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nullt,
    3,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_025(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &nully,
    1,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_026(void)
{

}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_027(void)
{

}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_028(void)
{

}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_029(void)
{

}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_030(void)
{

}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_031(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &nullt,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_032(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    NULL,
    &nullz,
    0,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_033(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    &nully,
    3,
    NULL
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_034(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    NULL,
    0,
    &param
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}

static void TestMossdspIntegral_mossdsp_integralgyrv3tfa_035(void)
{
#ifdef UNITTEST

float epsilon;
mossfw_data_qtf_t out[] = {
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f},
    {.t = 0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}
};
float vin[3][3];
uint32_t tin[3] = {0, 1, 4};
struct vector3tfa_s in;
struct vector3tfa_s nullt = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullx = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nully = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
struct vector3tfa_s nullz = {.t = NULL, .x = NULL, .y = NULL, .z = NULL};
in.t = tin;
in.x = vin[0];
in.y = vin[1];
in.z = vin[2];
nullt.x = vin[0];
nullt.y = vin[1];
nullt.z = vin[2];
nullx.t = tin;
nullx.y = vin[1];
nullx.z = vin[2];
nully.t = tin;
nully.x = vin[0];
nully.z = vin[2];
nullz.t = tin;
nullz.x = vin[0];
nullz.y = vin[1];
/* axis theta = pi/2, phi = pi/3 */
in.x[0] = sqrtf(0.125f) * acosf(0.0f); /*  sqrt(1/8) */
in.y[0] = sqrtf(0.375f) * acosf(0.0f); /*  sqrt(3/8) */
in.z[0] = sqrtf(0.5f)   * acosf(0.0f); /*  sqrt(1/2) */
in.x[1] = sqrtf(0.5f)   * acosf(0.0f); /* 2sqrt(1/8) */
in.y[1] = sqrtf(1.5f)   * acosf(0.0f); /* 2sqrt(3/8) */
in.z[1] = sqrtf(2.0f)   * acosf(0.0f); /* 2sqrt(1/2) */
in.x[2] = sqrtf(0.125f) * acosf(0.0f); /* 3sqrt(1/8) */
in.y[2] = sqrtf(0.375f) * acosf(0.0f); /* 3sqrt(3/8) */
in.z[2] = sqrtf(0.5f)   * acosf(0.0f); /* 3sqrt(1/2) */
struct mossdsp_integrategyr_param_s param = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)1, .w = 1.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
struct mossdsp_integrategyr_param_s q0 = {
    .lastout = {.tf = {.t = (uint32_t)0 - (uint32_t)0, .w = 0.0f, .x = 0.0f, .y = 0.0f, .z = 0.0f}},
    .dt = 0,
    .res = {.tv_sec = 0, .tv_nsec = 1000000}
};
int ret;
(void)in;
(void)nullx;
(void)nully;
(void)nullz;
(void)nullt;
(void)param;
(void)q0;


if (setjmp(g_testCaseEnv) == 0) {

ret = mossdsp_integrategyrv3tfa(
    out,
    NULL,
    1,
    &q0
);


}

epsilon = FLT_MIN;
PCU_ASSERT(ret == -1);
PCU_ASSERT(out[0].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[0].w && out[0].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].w) || ((0.0f) < -FLT_MAX && out[0].w < -FLT_MAX) || (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].w < 1.0f || 0.0f < out[0].w)));
PCU_ASSERT(((0.0f) - epsilon < out[0].x && out[0].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].x) || ((0.0f) < -FLT_MAX && out[0].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].x < 1.0f || 0.0f < out[0].x)));
PCU_ASSERT(((0.0f) - epsilon < out[0].y && out[0].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].y) || ((0.0f) < -FLT_MAX && out[0].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].y < 1.0f || 0.0f < out[0].y)));
PCU_ASSERT(((0.0f) - epsilon < out[0].z && out[0].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[0].z) || ((0.0f) < -FLT_MAX && out[0].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[0].z < 1.0f || 0.0f < out[0].z)));
PCU_ASSERT(out[1].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[1].w && out[1].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].w) || ((0.0f) < -FLT_MAX && out[1].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].w < 1.0f || 0.0f < out[1].w)));
PCU_ASSERT(((0.0f) - epsilon < out[1].x && out[1].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].x) || ((0.0f) < -FLT_MAX && out[1].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].x < 1.0f || 0.0f < out[1].x)));
PCU_ASSERT(((0.0f) - epsilon < out[1].y && out[1].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].y) || ((0.0f) < -FLT_MAX && out[1].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].y < 1.0f || 0.0f < out[1].y)));
PCU_ASSERT(((0.0f) - epsilon < out[1].z && out[1].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[1].z) || ((0.0f) < -FLT_MAX && out[1].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[1].z < 1.0f || 0.0f < out[1].z)));
PCU_ASSERT(out[2].t == 0);
PCU_ASSERT(((0.0f) - epsilon < out[2].w && out[2].w < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].w) || ((0.0f) < -FLT_MAX && out[2].w < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].w < 1.0f || 0.0f < out[2].w)));
PCU_ASSERT(((0.0f) - epsilon < out[2].x && out[2].x < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].x) || ((0.0f) < -FLT_MAX && out[2].x < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].x < 1.0f || 0.0f < out[2].x)));
PCU_ASSERT(((0.0f) - epsilon < out[2].y && out[2].y < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].y) || ((0.0f) < -FLT_MAX && out[2].y < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].y < 1.0f || 0.0f < out[2].y)));
PCU_ASSERT(((0.0f) - epsilon < out[2].z && out[2].z < (0.0f) + epsilon) || (FLT_MAX < (0.0f) && FLT_MAX < out[2].z) || ((0.0f) < -FLT_MAX && out[2].z < -FLT_MAX)|| (!((0.0f) < 1.0f || 0.0f < (0.0f)) && !(out[2].z < 1.0f || 0.0f < out[2].z)));


#endif
}


PCU_Suite* TestMossdspIntegral(void)
{
    static PCU_Test tests[] = {

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_001", .test = TestMossdspIntegral_integral_gyro_v3i_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_002", .test = TestMossdspIntegral_integral_gyro_v3i_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_003", .test = TestMossdspIntegral_integral_gyro_v3i_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_004", .test = TestMossdspIntegral_integral_gyro_v3i_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_005", .test = TestMossdspIntegral_integral_gyro_v3i_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_006", .test = TestMossdspIntegral_integral_gyro_v3i_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_007", .test = TestMossdspIntegral_integral_gyro_v3i_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_008", .test = TestMossdspIntegral_integral_gyro_v3i_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_009", .test = TestMossdspIntegral_integral_gyro_v3i_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_010", .test = TestMossdspIntegral_integral_gyro_v3i_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_011", .test = TestMossdspIntegral_integral_gyro_v3i_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_012", .test = TestMossdspIntegral_integral_gyro_v3i_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_013", .test = TestMossdspIntegral_integral_gyro_v3i_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_014", .test = TestMossdspIntegral_integral_gyro_v3i_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_015", .test = TestMossdspIntegral_integral_gyro_v3i_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_016", .test = TestMossdspIntegral_integral_gyro_v3i_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_017", .test = TestMossdspIntegral_integral_gyro_v3i_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_018", .test = TestMossdspIntegral_integral_gyro_v3i_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3i_019", .test = TestMossdspIntegral_integral_gyro_v3i_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_001", .test = TestMossdspIntegral_integral_gyro_v3f_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_002", .test = TestMossdspIntegral_integral_gyro_v3f_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_003", .test = TestMossdspIntegral_integral_gyro_v3f_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_004", .test = TestMossdspIntegral_integral_gyro_v3f_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_005", .test = TestMossdspIntegral_integral_gyro_v3f_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_006", .test = TestMossdspIntegral_integral_gyro_v3f_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_007", .test = TestMossdspIntegral_integral_gyro_v3f_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_008", .test = TestMossdspIntegral_integral_gyro_v3f_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_009", .test = TestMossdspIntegral_integral_gyro_v3f_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_010", .test = TestMossdspIntegral_integral_gyro_v3f_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_011", .test = TestMossdspIntegral_integral_gyro_v3f_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_012", .test = TestMossdspIntegral_integral_gyro_v3f_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_013", .test = TestMossdspIntegral_integral_gyro_v3f_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_014", .test = TestMossdspIntegral_integral_gyro_v3f_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_015", .test = TestMossdspIntegral_integral_gyro_v3f_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_016", .test = TestMossdspIntegral_integral_gyro_v3f_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_017", .test = TestMossdspIntegral_integral_gyro_v3f_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_018", .test = TestMossdspIntegral_integral_gyro_v3f_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3f_019", .test = TestMossdspIntegral_integral_gyro_v3f_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_001", .test = TestMossdspIntegral_integral_gyro_v3ti_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_002", .test = TestMossdspIntegral_integral_gyro_v3ti_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_003", .test = TestMossdspIntegral_integral_gyro_v3ti_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_004", .test = TestMossdspIntegral_integral_gyro_v3ti_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_005", .test = TestMossdspIntegral_integral_gyro_v3ti_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_006", .test = TestMossdspIntegral_integral_gyro_v3ti_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_007", .test = TestMossdspIntegral_integral_gyro_v3ti_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_008", .test = TestMossdspIntegral_integral_gyro_v3ti_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_009", .test = TestMossdspIntegral_integral_gyro_v3ti_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_010", .test = TestMossdspIntegral_integral_gyro_v3ti_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_011", .test = TestMossdspIntegral_integral_gyro_v3ti_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_012", .test = TestMossdspIntegral_integral_gyro_v3ti_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_013", .test = TestMossdspIntegral_integral_gyro_v3ti_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_014", .test = TestMossdspIntegral_integral_gyro_v3ti_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_015", .test = TestMossdspIntegral_integral_gyro_v3ti_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_016", .test = TestMossdspIntegral_integral_gyro_v3ti_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_017", .test = TestMossdspIntegral_integral_gyro_v3ti_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_018", .test = TestMossdspIntegral_integral_gyro_v3ti_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3ti_019", .test = TestMossdspIntegral_integral_gyro_v3ti_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_001", .test = TestMossdspIntegral_integral_gyro_v3tf_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_002", .test = TestMossdspIntegral_integral_gyro_v3tf_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_003", .test = TestMossdspIntegral_integral_gyro_v3tf_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_004", .test = TestMossdspIntegral_integral_gyro_v3tf_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_005", .test = TestMossdspIntegral_integral_gyro_v3tf_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_006", .test = TestMossdspIntegral_integral_gyro_v3tf_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_007", .test = TestMossdspIntegral_integral_gyro_v3tf_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_008", .test = TestMossdspIntegral_integral_gyro_v3tf_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_009", .test = TestMossdspIntegral_integral_gyro_v3tf_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_010", .test = TestMossdspIntegral_integral_gyro_v3tf_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_011", .test = TestMossdspIntegral_integral_gyro_v3tf_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_012", .test = TestMossdspIntegral_integral_gyro_v3tf_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_013", .test = TestMossdspIntegral_integral_gyro_v3tf_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_014", .test = TestMossdspIntegral_integral_gyro_v3tf_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_015", .test = TestMossdspIntegral_integral_gyro_v3tf_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_016", .test = TestMossdspIntegral_integral_gyro_v3tf_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_017", .test = TestMossdspIntegral_integral_gyro_v3tf_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_018", .test = TestMossdspIntegral_integral_gyro_v3tf_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_integral_gyro_v3tf_019", .test = TestMossdspIntegral_integral_gyro_v3tf_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_001", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_002", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_003", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_004", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_005", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_006", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_007", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_008", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_009", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_010", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_011", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_012", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_013", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_014", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_015", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_016", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_017", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_018", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_019", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_020", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_020, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_021", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_021, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_022", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_022, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_023", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_023, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_024", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_024, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_025", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_025, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_026", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_026, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_027", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_027, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_028", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_028, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_029", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_029, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3ia_030", .test = TestMossdspIntegral_mossdsp_integralgyrv3ia_030, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_001", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_002", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_003", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_004", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_005", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_006", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_007", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_008", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_009", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_010", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_011", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_012", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_013", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_014", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_015", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_016", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_017", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_018", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_019", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_020", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_020, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_021", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_021, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_022", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_022, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_023", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_023, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_024", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_024, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_025", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_025, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_026", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_026, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_027", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_027, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_028", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_028, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_029", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_029, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3fa_030", .test = TestMossdspIntegral_mossdsp_integralgyrv3fa_030, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_001", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_002", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_003", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_004", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_005", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_006", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_007", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_008", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_009", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_010", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_011", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_012", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_013", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_014", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_015", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_016", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_017", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_018", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_019", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_020", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_020, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_021", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_021, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_022", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_022, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_023", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_023, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_024", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_024, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_025", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_025, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_026", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_026, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_027", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_027, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_028", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_028, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_029", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_029, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_030", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_030, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_031", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_031, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_032", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_032, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_033", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_033, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_034", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_034, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tia_035", .test = TestMossdspIntegral_mossdsp_integralgyrv3tia_035, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_001", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_001, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_002", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_002, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_003", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_003, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_004", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_004, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_005", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_005, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_006", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_006, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_007", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_007, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_008", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_008, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_009", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_009, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_010", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_010, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_011", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_011, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_012", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_012, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_013", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_013, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_014", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_014, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_015", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_015, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_016", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_016, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_017", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_017, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_018", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_018, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_019", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_019, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_020", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_020, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_021", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_021, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_022", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_022, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_023", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_023, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_024", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_024, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_025", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_025, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_026", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_026, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_027", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_027, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_028", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_028, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_029", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_029, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_030", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_030, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_031", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_031, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_032", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_032, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_033", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_033, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_034", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_034, .ntimes = 1},
#endif

#if 1
        {.name = "TestMossdspIntegral_mossdsp_integralgyrv3tfa_035", .test = TestMossdspIntegral_mossdsp_integralgyrv3tfa_035, .ntimes = 1},
#endif

    };
    static PCU_Suite suite = {
        .name = "TestMossdspIntegral",
        .tests = tests,
        .ntests = sizeof(tests) / sizeof(tests[0]),
        .setup = (void *)0, .teardown = (void *)0, .initialize = (void *)0, .cleanup = (void *)0
    };
    return &suite;
}
